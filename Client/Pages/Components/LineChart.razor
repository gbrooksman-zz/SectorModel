@using SectorModel.Client
@using SectorModel.Shared.Entities
@using Microsoft.AspNetCore.Components
@using SectorModel.Client.Entities

@inject AppSettings appSettings
@inject HttpClient httpClient

@if(quoteList.Count == 0)
{
	<p>Loading...</p>
}
else
{

<figure>

    <svg width="@Width" height="@Height" xmlns="http://www.w3.org/2000/svg">
        <defs>
            <pattern id="grid" width="@gridWidth" height="@gridHeight" patternUnits="userSpaceOnUse">
                <rect width="@gridWidth" height="@gridHeight" fill="white" />
                <path d="M @gridWidth 0 L 0 0 0 @gridHeight" fill="none" stroke="gray" stroke-width="1" />
            </pattern>
        </defs>

        <rect width="100%" height="100%" fill="url(#grid)" stroke="gray" stroke-width="1" />

       @DrawDataElements()

    </svg>
</figure>

<figcaption>
    <ul>
        @DrawLegend()
    </ul>
</figcaption>
}

@code
{
    [Parameter] public Model Model { get; set; }

    [Parameter] public string Width { get; set; }

    [Parameter] public string Height { get; set; }

    [Parameter] public int HorizontalGridLines { get; set; } = 10;

    [Parameter] public int VerticalGridLines { get; set; } = 10;

    private List<Quote> quoteList = new List<Quote>();

    private decimal height = 0m;
    private decimal width = 0m;
    private decimal gridWidth = 0m;
    private decimal gridHeight = 0m;

    protected override async Task OnInitializedAsync()
    {
        height = decimal.Parse(Height);
        width = decimal.Parse(Width);

        gridHeight = height / (decimal)VerticalGridLines;
        gridWidth = width / (decimal)HorizontalGridLines;

        int quoteInterval = Utils.GetInterval(Model.StartDate, DateTime.Now);

        quoteList = await httpClient.GetFromJsonAsync<List<Quote>>($"model/GetQuotesForDateRange?modelId={Model.Id}&startdate={Model.StartDate}&stopdate={DateTime.Now}&interval={quoteInterval}");
    }

    private RenderFragment DrawLegend()
    {
        RenderFragment frag = null;

        string legendPath = string.Empty; //TODO: link this to text position

        int xCoord = 0; //TODO: link this to text position
        int yCoord = 0; //TODO: link this to text position
        int i = 0;      //TODO: link this to text position

        foreach (ModelItem mi in Model.ItemList)
        {
            frag += BuildLegendPath(legendPath, Utils.GetColor(i++), xCoord, yCoord);
            frag += BuildLegendText(mi.Equity.SymbolName, xCoord, yCoord);
        }

        return frag;
    }

    private RenderFragment DrawDataElements()
    {
        RenderFragment frag = null;

        List<Line> lines = new List<Line>();

        int ci = 1;

        foreach (ModelItem item in Model.ItemList)
        {
            List<Quote> quotes = quoteList.Where(e => e.EquityId == item.EquityId).ToList();

            if (quotes.Count > 0)
            {
                lines.Add(new Line()
                {
                    ColorIndex = ci++,
                    Title = item.Equity.SymbolName,
                    Path = BuildChartItemPath(quotes)
                });
            }
        }

        foreach (var line in lines)
        {
            frag += BuildLine(line);
        }

        return frag;
    }

    private string BuildChartItemPath( List<Quote> quotes)
    {

        /*
            |
            |
            | 
         y  |
            |
            |
            |           
            -------------------------------
                        x
        */

        decimal firstPrice = quotes.First().Price;
        decimal lowPrice = quotes.Min(q => q.Price);
        decimal highPrice = quotes.Max(q => q.Price);

        decimal heightScaleFactor = height / ((highPrice - lowPrice) * 2m);
        decimal widthScaleFactor = 0;

        decimal highVariance = highPrice > firstPrice ? highPrice - firstPrice : 1;
        decimal lowVariance = lowPrice < firstPrice ? firstPrice - lowPrice : 1;

        decimal x = 0;

        //decimal startY = height * .7m;

        decimal startY = (height * (lowVariance / highVariance));

        string path = $"M 0 {startY} L";

        int itemCount = quotes.Count;

        foreach (var quote in quotes)
        {
            path += $" {x += widthScaleFactor} {(startY - ((firstPrice - quote.Price) * heightScaleFactor)) } ";
            if (widthScaleFactor == 0) widthScaleFactor = width / itemCount;
        }

        return path;
    }


    RenderFragment BuildLine(Line line) => builder =>
    {
        builder.OpenElement(1, "path");
        builder.AddAttribute(2, "d", line.Path);
        builder.AddAttribute(3, "fill", "none");
        builder.AddAttribute(4, "stroke", Utils.GetColor(line.ColorIndex));
        builder.AddAttribute(5, "stroke-width", 4);
        builder.OpenElement(6, "title");
        builder.AddContent(7, line.Title);
        builder.CloseElement();
        builder.CloseElement();
    };

    RenderFragment BuildLegendPath(string legendPath, string color, int xCoord, int yCoord) => builder =>
    {
        builder.OpenElement(1, "path");
        builder.AddAttribute(2, "d", legendPath);
        builder.AddAttribute(3, "fill", "none");
        builder.AddAttribute(4, "stroke", color);
        builder.AddAttribute(5, "stroke-width", 4);
        builder.CloseElement();
    };

    RenderFragment BuildLegendText(string legendText, int xCoord, int yCoord) => builder =>
    {
        builder.OpenElement(1, "text");
        builder.AddAttribute(3, "x", xCoord);
        builder.AddAttribute(4, "y", yCoord);
        builder.AddContent(5, legendText);
        builder.CloseElement();
    };

}