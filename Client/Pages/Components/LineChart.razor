@using SectorModel.Client
@using SectorModel.Shared.Entities
@using Microsoft.AspNetCore.Components
@using SectorModel.Client.Entities

@inject AppSettings appSettings
@inject HttpClient httpClient

@if(quoteList.Count == 0)
{
	<p>Loading...</p>
}
else
{

<h3>@Model.Name</h3>

<figure>

    <svg width="@Width" height="@Height" xmlns="http://www.w3.org/2000/svg">
        <defs>
            <pattern id="grid" width="@gridWidth" height="@gridHeight" patternUnits="userSpaceOnUse">
                <rect width="@gridWidth" height="@gridHeight" fill="white" />
                <path d="M @gridWidth 0 L 0 0 0 @gridHeight" fill="none" stroke="gray" stroke-width="1" />
            </pattern>
        </defs>

        <rect width="100%" height="100%" fill="url(#grid)" stroke="gray" stroke-width="1" />

       @DrawDataElements()

    </svg>
</figure>

<figcaption>
    <ul>
        @DrawLegend()
    </ul>
</figcaption>
}

@code
{
    [Parameter] public Model Model { get; set; }

    [Parameter] public string Width { get; set; }

    [Parameter] public string Height { get; set; }

    [Parameter] public int HorizontalGridLines { get; set; } = 10;

    [Parameter] public int VerticalGridLines { get; set; } = 10;

    [Parameter] public bool RelativeCompare { get; set; }

    protected double gridWidth = 0;
    protected double gridHeight = 0;  
	private List<Quote> quoteList = new List<Quote>();

    protected override async Task OnInitializedAsync()
    {       
        gridWidth = double.Parse(Width) / (double)HorizontalGridLines;
        gridHeight = double.Parse(Height) / (double)VerticalGridLines;

        int quoteInterval = Utils.GetInterval(Model.StartDate, DateTime.Now);

        quoteList = await httpClient.GetFromJsonAsync<List<Quote>>($"model/GetQuotesForDateRange?modelId={Model.Id}&startdate={Model.StartDate}&stopdate={DateTime.Now}&interval={quoteInterval}");
	}

    private string BuildChartItemPath( List<Quote> itemQuotes)
    {
        decimal height = int.Parse(Height);
        decimal width = int.Parse(Width);

        decimal startY = height * (decimal).7 ;

        string path = $"M 0 {startY} L";

        decimal firstPrice = itemQuotes.First().Price;
        decimal lowPrice = itemQuotes.Min(q => q.Price);
        decimal highPrice = itemQuotes.Max(q => q.Price);

        decimal heightScaleFactor = height / ((highPrice - lowPrice) * 2 );
        decimal widthScaleFactor = 0; 
        decimal x = 0;

        foreach (var quote in itemQuotes)
        {
            decimal price = quote.Price;
            path += $" {x += widthScaleFactor} {(startY - ((firstPrice - price) * heightScaleFactor)) } ";
            if (widthScaleFactor == 0) widthScaleFactor = width / itemQuotes.Count;
        }

        return path;
    }


    RenderFragment BuildLine(string linePath, int colorValue) => builder =>
    {
        builder.OpenElement(1, "path");
        builder.AddAttribute(2, "d", linePath);
        builder.AddAttribute(3, "fill", "none");
        builder.AddAttribute(4, "stroke", Utils.GetColor(colorValue));
        builder.AddAttribute(5, "stroke-width", 2);
        builder.CloseElement();
    };

    RenderFragment BuildLegendPath(string legendPath, string color, int xCoord, int yCoord) => builder =>
    {
        builder.OpenElement(1, "path");
        builder.AddAttribute(2, "d", legendPath);
        builder.AddAttribute(3, "fill", "none");
        builder.AddAttribute(4, "stroke", color);
        builder.AddAttribute(5, "stroke-width", 2);
        builder.CloseElement();
    };

    RenderFragment BuildLegendText(string legendText, int xCoord, int yCoord) => builder =>
    {
        builder.OpenElement(1, "text");
        builder.AddAttribute(3, "x", xCoord);
        builder.AddAttribute(4, "y", yCoord);
        builder.AddContent(5, legendText);
        builder.CloseElement();
    };

    private RenderFragment DrawLegend()
    {
        RenderFragment frag = null;

        string legendPath = string.Empty;

        int xCoord = 0;
        int yCoord = 0;
        int i = 0;

        foreach (ModelItem mi in Model.ItemList)
        {
            frag += BuildLegendPath(legendPath, Utils.GetColor(i++), xCoord, yCoord);
            frag += BuildLegendText(mi.Equity.SymbolName, xCoord, yCoord);
        }

        return frag;
    }

    private RenderFragment DrawDataElements()
    {
        RenderFragment frag = null;
        string linePath = string.Empty;
        string legendPath = string.Empty;
        string legendText = string.Empty;

        List<ChartItem> chartItems = new List<ChartItem>();

       int x = 1;

       foreach (ModelItem item in Model.ItemList)
        {
            List<Quote> quotes = quoteList.Where(e => e.EquityId == item.EquityId).ToList();

			if (quotes.Count > 0)
			{
				decimal startingPrice = quotes.FirstOrDefault().Price;
				string symbolName = item.Equity.SymbolName;

				chartItems.Add(new ChartItem()
				{
					ColorIndex = x,
					LowPrice = quotes.Min(q => q.Price),
					HighPrice = quotes.Max(q => q.Price),
					LegendText = symbolName,
					StartPrice = startingPrice,
					ChartPath = BuildChartItemPath(quotes)
				});
			}

            x++;
        }

        foreach (var chartItem in chartItems)
        {
            frag += BuildLine(chartItem.ChartPath, chartItem.ColorIndex);
        }

        return frag;
    }
}