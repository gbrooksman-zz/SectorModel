@using SectorModel.Client
@using SectorModel.Shared.Entities
@using Microsoft.AspNetCore.Components
@using SectorModel.Client.Entities

@inject AppSettings appSettings
@inject HttpClient httpClient

@if(quoteList.Count == 0)
{
	<p>Loading...</p>
}
else
{

<figure>

    <svg width="@Width" height="@Height" xmlns="http://www.w3.org/2000/svg">
        <defs>
            <pattern id="grid" width="@gridWidth" height="@gridHeight" patternUnits="userSpaceOnUse">
                <rect width="@gridWidth" height="@gridHeight" fill="white" />
                <path d="M @gridWidth 0 L 0 0 0 @gridHeight" fill="none" stroke="gray" stroke-width="1" />
            </pattern>
        </defs>

        <rect width="100%" height="100%" fill="url(#grid)" stroke="gray" stroke-width="1" />

       @DrawDataElements()

    </svg>
</figure>

<figcaption>
    <ul>
        @DrawLegend()
    </ul>
</figcaption>

<span>startY: @chart.StartY  </span>
<span>variance: </span>

}

@code
{
    [Parameter] public Model Model { get; set; }

    [Parameter] public string Width { get; set; }

    [Parameter] public string Height { get; set; }

    [Parameter] public int HorizontalGridLines { get; set; } = 10;

    [Parameter] public int VerticalGridLines { get; set; } = 10;

    private List<Quote> quoteList = new List<Quote>();

    private decimal height = 0m;
    private decimal width = 0m;
    private decimal gridWidth = 0m;
    private decimal gridHeight = 0m;

    private LineSet chart = new LineSet();


    protected override async Task OnInitializedAsync()
    {
        chart.Lines = new List<Line>();

        height = decimal.Parse(Height);
        width = decimal.Parse(Width);

        gridHeight = height / (decimal)VerticalGridLines;
        gridWidth = width / (decimal)HorizontalGridLines;

        int quoteInterval = Utils.GetInterval(Model.StartDate, DateTime.Now);

        quoteList = await httpClient.GetFromJsonAsync<List<Quote>>($"model/GetQuotesForDateRange?modelId={Model.Id}&startdate={Model.StartDate}&stopdate={DateTime.Now}&interval={quoteInterval}");

        int ci = 1;

        foreach (ModelItem mi in Model.ItemList)
        {
            List<Quote> quotes = quoteList.Where(e => e.EquityId == mi.EquityId).ToList();

            chart.Lines.Add(new Line
            {
                EquityId = mi.EquityId,
                Title = mi.Equity.SymbolName,
                ColorIndex = ci++,
                LengendPath = mi.Equity.SymbolName,
                FirstPrice = quotes.First().Price,
                HighPrice = quotes.Max(q => q.Price),
                LowPrice = quotes.Min(q => q.Price)
            });
        }

        chart.StartX = 0;
        chart.StartY = CalculateStartingY();
    }

    private RenderFragment DrawLegend()
    {
        RenderFragment frag = null;

        string legendPath = string.Empty; //TODO: link this to text position

        int xCoord = 0; //TODO: link this to text position
        int yCoord = 0; //TODO: link this to text position       

        foreach (Line line in chart.Lines)
        {
            frag += BuildLegendPath(legendPath, Utils.GetColor(line.ColorIndex), xCoord, yCoord);
            frag += BuildLegendText(line.Title, xCoord, yCoord);
        }

        return frag;
    }

    private RenderFragment DrawDataElements()
    {
        RenderFragment frag = null;

        foreach (Line line in chart.Lines)
        {
            List<Quote> quotes = quoteList.Where(e => e.EquityId == line.EquityId).ToList();
            line.Path = BuildChartItemPath(quotes);
            frag += BuildLine(line);
        }

        return frag;
    }


    private decimal CalculateStartingY()
    {
        decimal startY = height /2m;

        foreach (Line line in chart.Lines)
        {
            // decimal highVariance = line.HighPrice > line.FirstPrice ? 1 - (line.HighPrice / line.FirstPrice) : 0;
            decimal lowVariance =  (line.LowPrice / line.FirstPrice);

            if (lowVariance > 0)
            {
                startY = Math.Min(startY, (height * lowVariance) + 20m);               
            }
        }

        return startY;
    }


    private string BuildChartItemPath( List<Quote> quotes)
    {

        /* 
        
            |
            |
            | 
         y  |
            |
            |
            |           
            -------------------------------
                       x
        */

        decimal firstPrice = quotes.First().Price;
        decimal lowPrice = quotes.Min(q => q.Price);
        decimal highPrice = quotes.Max(q => q.Price);

        decimal heightScaleFactor = height / ((highPrice - lowPrice) * 2m);
        decimal widthScaleFactor = 0;

        decimal highVariance = highPrice > firstPrice ? highPrice - firstPrice : 1;
        decimal lowVariance = lowPrice < firstPrice ? firstPrice - lowPrice : 1;

        decimal x = 0;

        //decimal startY = height * .7m;

        decimal startY = chart.StartY;

        string path = $"M 0 {startY} L";

        int itemCount = quotes.Count;

        foreach (var quote in quotes)
        {
            path += $" {x += widthScaleFactor} {(startY - ((firstPrice - quote.Price) * heightScaleFactor)) } ";
            if (widthScaleFactor == 0) widthScaleFactor = width / itemCount;
        }

        return path;
    }


    RenderFragment BuildLine(Line line) => builder =>
    {
        builder.OpenElement(1, "path");
        builder.AddAttribute(2, "d", line.Path);
        builder.AddAttribute(3, "fill", "none");
        builder.AddAttribute(4, "stroke", Utils.GetColor(line.ColorIndex));
        builder.AddAttribute(5, "stroke-width", 4);
        builder.OpenElement(6, "title");
        builder.AddContent(7, line.Title);
        builder.CloseElement();
        builder.CloseElement();
    };

    RenderFragment BuildLegendPath(string legendPath, string color, int xCoord, int yCoord) => builder =>
    {
        builder.OpenElement(1, "path");
        builder.AddAttribute(2, "d", legendPath);
        builder.AddAttribute(3, "fill", "none");
        builder.AddAttribute(4, "stroke", color);
        builder.AddAttribute(5, "stroke-width", 4);
        builder.CloseElement();
    };

    RenderFragment BuildLegendText(string legendText, int xCoord, int yCoord) => builder =>
    {
        builder.OpenElement(1, "text");
        builder.AddAttribute(3, "x", xCoord);
        builder.AddAttribute(4, "y", yCoord);
        builder.AddContent(5, legendText);
        builder.CloseElement();
    };

}